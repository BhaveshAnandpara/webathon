{"ast":null,"code":"// import './style.css'\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'; //(use it after camera)\n\nimport { BufferAttribute, BufferGeometry } from 'three'; // import dat from 'dat.gui'\n\nimport { RectAreaLightHelper } from 'three/examples/jsm/helpers/RectAreaLightHelper.js'; //Gui\n// const gui = new dat.GUI()\n//Scene\n\nconst scene = new THREE.Scene(); //Textures\n\nconst texturLoader = new THREE.TextureLoader();\nconst star = texturLoader.load('textures/particles/2.png'); //Sphere PArticles\n// //geometry \n// const particalGeometry = new THREE.SphereBufferGeometry( 1, 16, 16)\n//Material\n// const particleMaterial = new THREE.PointsMaterial({\n//     size : 0.02,\n//     sizeAttenuation : true //Gives perspective small if far and big if near\n// })    \n// //Particals\n// const particle = new THREE.Points(particalGeometry, particleMaterial)\n// scene.add(particle)\n//Customs Geometry\n\nconst particalGeometry = new THREE.BufferGeometry();\nconst count = 20000;\nconst positions = new Float32Array(count * 3); //Count * 3 because there is x  ,y, ,z to a single particle\n\nconst colors = new Float32Array(count * 3);\n\nfor (let i = 0; i < count * 3; i++) {\n  positions[i] = (Math.random() - 0.5) * 10;\n  colors[i] = Math.random();\n}\n\nparticalGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\nparticalGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)); //Material\n\nconst particleMaterial = new THREE.PointsMaterial({\n  size: 0.1,\n  sizeAttenuation: true,\n  //Gives perspective small if far and big if near\n  // color : 0xff88cc, //hide so other colors won't be impacted\n  transparent: true,\n  alphaMap: star,\n  //shows black edges from image \n  // alphaTest : 0.001 //Basically Telling renderer to not render the black part of image\n  // depthTest : false, //Basically says donot render which is forward and which is behind solves issue but not good when there is an object\n  depthWrite: false,\n  //THis solves all our Issues\n  blending: THREE.AdditiveBlending,\n  //Glows if there is particle over another ,\n  vertexColors: true //Whithout it wont change colors\n\n}); //Particals\n\nconst particle = new THREE.Points(particalGeometry, particleMaterial);\nscene.add(particle); // //Cube\n// const square = new THREE.Mesh(\n//     new THREE.BoxBufferGeometry(1 , 1 , 1),\n//     new THREE.MeshBasicMaterial()\n// )\n// scene.add(square)\n\n/**\r\n * Lights\r\n */\n\nconst ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\nscene.add(ambientLight); //rezise function\n// window.addEventListener('resize' , () => {\n// sizes.width = window.innerWidth,\n//    sizes.height = window.innerHeight,\n//    camera.aspect = sizes.width / sizes.height,\n//    camera.updateProjectionMatrix()\n//    renderer.setSize(sizes.width ,sizes.height) //Sets size for the renderer \n// })\n\nconst sizes = {\n  width: window.innerWidth,\n  height: window.innerHeight\n};\n/**\r\n * Camera\r\n */\n\nconst camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height);\ncamera.position.z = 3;\nscene.add(camera);\nconst canvas = document.querySelector('.webgl');\nconsole.log(canvas);\nconst renderer = new THREE.WebGLRenderer({\n  canvas: canvas // Canvas for WEBGL\n\n});\nrenderer.setSize(sizes.width, sizes.height); //Sets size for the renderer \n//Controls \n\nconst controls = new OrbitControls(camera, canvas);\ncontrols.enableDamping = true; //need to update per frame (in tick function)\n//Clock \n\nconst clock = new THREE.Clock(); //Animations\n\nexport default function tick() {\n  //Creating a function for Animation \n  const elapsedTime = clock.getElapsedTime(); //UPdate Particles\n  //All Particles\n  // particle.position.y = - elapsedTime * 0.02 \n  //By Single Particle (Very BAd for performance as we are using it to change position for every particle)\n\n  for (let i = 0; i < count; i++) {\n    const n = i * 3; //So that it can access direct x position of every particle -- xyz xyz xyz so that it can jump every 3 elements\n\n    const x = particalGeometry.attributes.position.array[n];\n    particalGeometry.attributes.position.array[n + 1] = Math.sin(elapsedTime + x); //n + 1 will access y \n  }\n\n  particalGeometry.attributes.position.needsUpdate = true; //to update attributes\n  //Update Controls\n\n  controls.update(); //render\n\n  renderer.render(scene, camera);\n  window.requestAnimationFrame(tick); // requestAnimationFrame() runs at 60 Frames per Second(FPS)\n}","map":{"version":3,"names":["THREE","OrbitControls","BufferAttribute","BufferGeometry","RectAreaLightHelper","scene","Scene","texturLoader","TextureLoader","star","load","particalGeometry","count","positions","Float32Array","colors","i","Math","random","setAttribute","particleMaterial","PointsMaterial","size","sizeAttenuation","transparent","alphaMap","depthWrite","blending","AdditiveBlending","vertexColors","particle","Points","add","ambientLight","AmbientLight","sizes","width","window","innerWidth","height","innerHeight","camera","PerspectiveCamera","position","z","canvas","document","querySelector","console","log","renderer","WebGLRenderer","setSize","controls","enableDamping","clock","Clock","tick","elapsedTime","getElapsedTime","n","x","attributes","array","sin","needsUpdate","update","render","requestAnimationFrame"],"sources":["C:/Webathon/artisticdots/src/Components/3D/bg.js"],"sourcesContent":["// import './style.css'\r\nimport * as THREE from 'three'\r\nimport {OrbitControls} from 'three/examples/jsm/controls/OrbitControls' //(use it after camera)\r\nimport { BufferAttribute, BufferGeometry } from 'three'\r\n// import dat from 'dat.gui'\r\nimport { RectAreaLightHelper } from 'three/examples/jsm/helpers/RectAreaLightHelper.js'\r\n\r\n\r\n//Gui\r\n\r\n// const gui = new dat.GUI()\r\n\r\n//Scene\r\nconst scene = new THREE.Scene()\r\n\r\n//Textures\r\n\r\nconst texturLoader = new THREE.TextureLoader()\r\n\r\nconst star = texturLoader.load('textures/particles/2.png')\r\n\r\n\r\n\r\n\r\n//Sphere PArticles\r\n\r\n// //geometry \r\n// const particalGeometry = new THREE.SphereBufferGeometry( 1, 16, 16)\r\n\r\n//Material\r\n// const particleMaterial = new THREE.PointsMaterial({\r\n    //     size : 0.02,\r\n//     sizeAttenuation : true //Gives perspective small if far and big if near\r\n// })    \r\n\r\n// //Particals\r\n\r\n// const particle = new THREE.Points(particalGeometry, particleMaterial)\r\n// scene.add(particle)\r\n\r\n\r\n\r\n\r\n//Customs Geometry\r\n\r\nconst particalGeometry = new THREE.BufferGeometry()\r\nconst count = 20000\r\n\r\nconst positions = new Float32Array(count * 3) //Count * 3 because there is x  ,y, ,z to a single particle\r\nconst colors = new Float32Array(count * 3)  \r\n\r\nfor(let i = 0 ; i < count *3 ; i++){\r\n    positions[i] = (Math.random() - 0.5) * 10\r\n    colors[i] = Math.random()\r\n}\r\n\r\nparticalGeometry.setAttribute(\r\n    'position', \r\n    new THREE.BufferAttribute(positions , 3)\r\n)\r\n\r\nparticalGeometry.setAttribute(\r\n    'color', \r\n    new THREE.BufferAttribute(colors , 3)\r\n)\r\n\r\n//Material\r\nconst particleMaterial = new THREE.PointsMaterial({\r\n    size : 0.1,\r\n    sizeAttenuation : true, //Gives perspective small if far and big if near\r\n    // color : 0xff88cc, //hide so other colors won't be impacted\r\n    transparent : true,\r\n    alphaMap : star, //shows black edges from image \r\n    // alphaTest : 0.001 //Basically Telling renderer to not render the black part of image\r\n    // depthTest : false, //Basically says donot render which is forward and which is behind solves issue but not good when there is an object\r\n    depthWrite : false, //THis solves all our Issues\r\n    blending : THREE.AdditiveBlending, //Glows if there is particle over another ,\r\n    vertexColors : true //Whithout it wont change colors\r\n\r\n\r\n    \r\n \r\n})   \r\n\r\n//Particals\r\n\r\nconst particle = new THREE.Points(particalGeometry, particleMaterial)\r\nscene.add(particle)\r\n\r\n// //Cube\r\n\r\n// const square = new THREE.Mesh(\r\n//     new THREE.BoxBufferGeometry(1 , 1 , 1),\r\n//     new THREE.MeshBasicMaterial()\r\n// )\r\n// scene.add(square)\r\n\r\n\r\n/**\r\n * Lights\r\n */\r\n\r\nconst ambientLight = new THREE.AmbientLight(0xffffff , 0.5)\r\nscene.add(ambientLight)\r\n//rezise function\r\n\r\n// window.addEventListener('resize' , () => {\r\n\r\n// sizes.width = window.innerWidth,\r\n//    sizes.height = window.innerHeight,\r\n\r\n//    camera.aspect = sizes.width / sizes.height,\r\n//    camera.updateProjectionMatrix()\r\n\r\n//    renderer.setSize(sizes.width ,sizes.height) //Sets size for the renderer \r\n\r\n// })\r\n\r\n\r\n\r\nconst sizes = {\r\n\r\n    width : window.innerWidth,\r\n    height : window.innerHeight,\r\n}\r\n\r\n\r\n/**\r\n * Camera\r\n */\r\n\r\n\r\nconst camera = new THREE.PerspectiveCamera(75 , (sizes.width / sizes.height) )\r\n\r\ncamera.position.z = 3 \r\n\r\nscene.add(camera)\r\n\r\n\r\n\r\n\r\nconst  canvas = document.querySelector('.webgl')\r\nconsole.log(canvas)\r\n\r\n\r\nconst  renderer = new THREE.WebGLRenderer({\r\n    canvas : canvas,  // Canvas for WEBGL\r\n})\r\n \r\nrenderer.setSize(sizes.width ,sizes.height) //Sets size for the renderer \r\n\r\n\r\n//Controls \r\nconst controls = new OrbitControls(camera , canvas)\r\ncontrols.enableDamping = true //need to update per frame (in tick function)\r\n\r\n//Clock \r\n\r\nconst clock = new THREE.Clock()\r\n\r\n//Animations\r\n\r\nexport default function tick  () { //Creating a function for Animation \r\n\r\n\r\n    const elapsedTime = clock.getElapsedTime()\r\n\r\n    //UPdate Particles\r\n\r\n    //All Particles\r\n    // particle.position.y = - elapsedTime * 0.02 \r\n\r\n    //By Single Particle (Very BAd for performance as we are using it to change position for every particle)\r\n\r\n    for(let i = 0 ; i < count ; i ++){\r\n\r\n        const n = i * 3 //So that it can access direct x position of every particle -- xyz xyz xyz so that it can jump every 3 elements\r\n\r\n        const x = particalGeometry.attributes.position.array[n]\r\n        particalGeometry.attributes.position.array[n + 1] = Math.sin(elapsedTime + x) //n + 1 will access y \r\n\r\n    }\r\n\r\n    particalGeometry.attributes.position.needsUpdate = true //to update attributes\r\n    \r\n    //Update Controls\r\n    controls.update()\r\n\r\n\r\n    //render\r\n    renderer.render(scene , camera);    \r\n\r\n    window.requestAnimationFrame(tick) // requestAnimationFrame() runs at 60 Frames per Second(FPS)\r\n\r\n\r\n}\r\n\r\n\r\n"],"mappings":"AAAA;AACA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAAQC,aAAR,QAA4B,2CAA5B,C,CAAwE;;AACxE,SAASC,eAAT,EAA0BC,cAA1B,QAAgD,OAAhD,C,CACA;;AACA,SAASC,mBAAT,QAAoC,mDAApC,C,CAGA;AAEA;AAEA;;AACA,MAAMC,KAAK,GAAG,IAAIL,KAAK,CAACM,KAAV,EAAd,C,CAEA;;AAEA,MAAMC,YAAY,GAAG,IAAIP,KAAK,CAACQ,aAAV,EAArB;AAEA,MAAMC,IAAI,GAAGF,YAAY,CAACG,IAAb,CAAkB,0BAAlB,CAAb,C,CAKA;AAEA;AACA;AAEA;AACA;AACI;AACJ;AACA;AAEA;AAEA;AACA;AAKA;;AAEA,MAAMC,gBAAgB,GAAG,IAAIX,KAAK,CAACG,cAAV,EAAzB;AACA,MAAMS,KAAK,GAAG,KAAd;AAEA,MAAMC,SAAS,GAAG,IAAIC,YAAJ,CAAiBF,KAAK,GAAG,CAAzB,CAAlB,C,CAA8C;;AAC9C,MAAMG,MAAM,GAAG,IAAID,YAAJ,CAAiBF,KAAK,GAAG,CAAzB,CAAf;;AAEA,KAAI,IAAII,CAAC,GAAG,CAAZ,EAAgBA,CAAC,GAAGJ,KAAK,GAAE,CAA3B,EAA+BI,CAAC,EAAhC,EAAmC;EAC/BH,SAAS,CAACG,CAAD,CAAT,GAAe,CAACC,IAAI,CAACC,MAAL,KAAgB,GAAjB,IAAwB,EAAvC;EACAH,MAAM,CAACC,CAAD,CAAN,GAAYC,IAAI,CAACC,MAAL,EAAZ;AACH;;AAEDP,gBAAgB,CAACQ,YAAjB,CACI,UADJ,EAEI,IAAInB,KAAK,CAACE,eAAV,CAA0BW,SAA1B,EAAsC,CAAtC,CAFJ;AAKAF,gBAAgB,CAACQ,YAAjB,CACI,OADJ,EAEI,IAAInB,KAAK,CAACE,eAAV,CAA0Ba,MAA1B,EAAmC,CAAnC,CAFJ,E,CAKA;;AACA,MAAMK,gBAAgB,GAAG,IAAIpB,KAAK,CAACqB,cAAV,CAAyB;EAC9CC,IAAI,EAAG,GADuC;EAE9CC,eAAe,EAAG,IAF4B;EAEtB;EACxB;EACAC,WAAW,EAAG,IAJgC;EAK9CC,QAAQ,EAAGhB,IALmC;EAK7B;EACjB;EACA;EACAiB,UAAU,EAAG,KARiC;EAQ1B;EACpBC,QAAQ,EAAG3B,KAAK,CAAC4B,gBAT6B;EASX;EACnCC,YAAY,EAAG,IAV+B,CAU1B;;AAV0B,CAAzB,CAAzB,C,CAiBA;;AAEA,MAAMC,QAAQ,GAAG,IAAI9B,KAAK,CAAC+B,MAAV,CAAiBpB,gBAAjB,EAAmCS,gBAAnC,CAAjB;AACAf,KAAK,CAAC2B,GAAN,CAAUF,QAAV,E,CAEA;AAEA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA,MAAMG,YAAY,GAAG,IAAIjC,KAAK,CAACkC,YAAV,CAAuB,QAAvB,EAAkC,GAAlC,CAArB;AACA7B,KAAK,CAAC2B,GAAN,CAAUC,YAAV,E,CACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;;AAIA,MAAME,KAAK,GAAG;EAEVC,KAAK,EAAGC,MAAM,CAACC,UAFL;EAGVC,MAAM,EAAGF,MAAM,CAACG;AAHN,CAAd;AAOA;AACA;AACA;;AAGA,MAAMC,MAAM,GAAG,IAAIzC,KAAK,CAAC0C,iBAAV,CAA4B,EAA5B,EAAkCP,KAAK,CAACC,KAAN,GAAcD,KAAK,CAACI,MAAtD,CAAf;AAEAE,MAAM,CAACE,QAAP,CAAgBC,CAAhB,GAAoB,CAApB;AAEAvC,KAAK,CAAC2B,GAAN,CAAUS,MAAV;AAKA,MAAOI,MAAM,GAAGC,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAhB;AACAC,OAAO,CAACC,GAAR,CAAYJ,MAAZ;AAGA,MAAOK,QAAQ,GAAG,IAAIlD,KAAK,CAACmD,aAAV,CAAwB;EACtCN,MAAM,EAAGA,MAD6B,CACpB;;AADoB,CAAxB,CAAlB;AAIAK,QAAQ,CAACE,OAAT,CAAiBjB,KAAK,CAACC,KAAvB,EAA8BD,KAAK,CAACI,MAApC,E,CAA4C;AAG5C;;AACA,MAAMc,QAAQ,GAAG,IAAIpD,aAAJ,CAAkBwC,MAAlB,EAA2BI,MAA3B,CAAjB;AACAQ,QAAQ,CAACC,aAAT,GAAyB,IAAzB,C,CAA8B;AAE9B;;AAEA,MAAMC,KAAK,GAAG,IAAIvD,KAAK,CAACwD,KAAV,EAAd,C,CAEA;;AAEA,eAAe,SAASC,IAAT,GAAkB;EAAE;EAG/B,MAAMC,WAAW,GAAGH,KAAK,CAACI,cAAN,EAApB,CAH6B,CAK7B;EAEA;EACA;EAEA;;EAEA,KAAI,IAAI3C,CAAC,GAAG,CAAZ,EAAgBA,CAAC,GAAGJ,KAApB,EAA4BI,CAAC,EAA7B,EAAiC;IAE7B,MAAM4C,CAAC,GAAG5C,CAAC,GAAG,CAAd,CAF6B,CAEb;;IAEhB,MAAM6C,CAAC,GAAGlD,gBAAgB,CAACmD,UAAjB,CAA4BnB,QAA5B,CAAqCoB,KAArC,CAA2CH,CAA3C,CAAV;IACAjD,gBAAgB,CAACmD,UAAjB,CAA4BnB,QAA5B,CAAqCoB,KAArC,CAA2CH,CAAC,GAAG,CAA/C,IAAoD3C,IAAI,CAAC+C,GAAL,CAASN,WAAW,GAAGG,CAAvB,CAApD,CAL6B,CAKiD;EAEjF;;EAEDlD,gBAAgB,CAACmD,UAAjB,CAA4BnB,QAA5B,CAAqCsB,WAArC,GAAmD,IAAnD,CArB6B,CAqB2B;EAExD;;EACAZ,QAAQ,CAACa,MAAT,GAxB6B,CA2B7B;;EACAhB,QAAQ,CAACiB,MAAT,CAAgB9D,KAAhB,EAAwBoC,MAAxB;EAEAJ,MAAM,CAAC+B,qBAAP,CAA6BX,IAA7B,EA9B6B,CA8BM;AAGtC"},"metadata":{},"sourceType":"module"}